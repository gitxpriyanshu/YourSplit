# YourSplit

An optimized peer-to-peer expense splitting platform that minimizes the number of settlement transactions using graph-based algorithms.

---

## 1. Problem Statement

### Problem Title
Peer-to-Peer Expense Splitter with Debt Simplification

### Problem Description
Managing shared expenses in groups often results in complex debt chains and unnecessary transactions. Existing tools calculate balances but do not optimize settlements.

### Target Users
- Flatmates
- Travel groups
- Friends
- Small teams
- Families

### Existing Gaps
- No transaction minimization
- Redundant payment chains
- Poor visualization of debt graph
- Lack of optimization layer

---

## 2. Problem Understanding & Approach

### Root Cause Analysis
Most expense splitters calculate balances but do not apply graph optimization techniques to reduce total settlement transactions.

### Solution Strategy
Model users as nodes in a graph and debts as directed weighted edges.
Apply a Minimum Cash Flow algorithm to reduce the number of transactions while preserving net balances.

---

## 3. Proposed Solution

### Solution Overview
YourSplit calculates group expenses, determines net balances, and applies a graph-based optimization algorithm to minimize required settlements.

### Core Idea
Use a greedy minimum cash flow algorithm to match largest debtor with largest creditor until all balances settle.

### Key Features
- Group expense tracking
- Net balance calculation
- Debt simplification engine
- Before vs After settlement comparison

---

## 4. System Architecture

### High-Level Flow
User → Next.js Frontend → API Routes → Optimization Engine → PostgreSQL Database → Response

### Architecture Description
The system follows a full-stack TypeScript architecture using Next.js App Router. 
Frontend components interact with API routes that handle business logic. 
The optimization engine processes net balances and computes minimum settlement transactions. 
All financial data is stored in PostgreSQL using Prisma ORM.

### Architecture Diagram
(To be added before final submission)

---

## 5. Database Design

### ER Diagram
(To be added before final submission)

### ER Diagram Description

The system consists of the following core entities:

1. User  
   - id (UUID)  
   - name  
   - email  
   - createdAt  

2. Group  
   - id (UUID)  
   - name  
   - createdAt  

3. Expense  
   - id (UUID)  
   - groupId (Foreign Key)  
   - paidById (Foreign Key → User)  
   - amount (Integer, stored in cents)  
   - createdAt  

4. Settlement  
   - id (UUID)  
   - groupId (Foreign Key)  
   - fromUser  
   - toUser  
   - amount (Integer, stored in cents)  
   - optimized (Boolean)  
   - createdAt  

Relationships:
- A Group has many Users (many-to-many).
- A Group has many Expenses.
- An Expense belongs to one Group.
- An Expense is paid by one User.
- Settlements represent optimized transactions between users.

---

## 6. Dataset Selected

### Dataset Name
User-Generated Expense Data

### Source
Manually entered group expense records within the application

### Data Type
Structured financial transaction data (numerical + relational)

### Selection Reason
The optimization model requires structured expense data containing:
- User IDs
- Paid amount
- Group associations
- Debt relationships

Since the system focuses on real-time expense splitting, the dataset is dynamically generated by users.

### Preprocessing Steps
- Convert all monetary values into integer cents to avoid floating point precision errors.
- Compute net balance per user within each group.
- Separate creditors and debtors before applying optimization.

---

## 7. Model Selected

### Model Name
Graph-Based Minimum Cash Flow Optimization Algorithm

### Selection Reasoning
The core problem is minimizing the number of settlement transactions while preserving correct net balances.

Instead of using machine learning, the problem is modeled as a directed weighted graph:
- Nodes represent users.
- Edges represent debt relationships.
- We compute net balances and apply a greedy matching strategy between largest debtor and largest creditor.

This guarantees reduction in transaction count while maintaining financial correctness.

### Alternatives Considered
- Naive settlement (direct pairwise payments)
- Circular debt resolution without optimization
- Linear debt propagation

These approaches do not guarantee minimal transactions.

### Evaluation Metrics
- Reduction in number of settlement transactions
- Correct preservation of net balances
- Time complexity efficiency (O(n log n))

---

## 8. Technology Stack

### Frontend
- Next.js 14 (App Router)
- TypeScript
- Tailwind CSS

### Backend
- Next.js API Routes
- TypeScript
- Prisma ORM

### ML/AI
- Not applicable (Graph-based optimization algorithm implemented manually)

### Database
- PostgreSQL

### Deployment
- Vercel (Frontend + API)
- PostgreSQL Cloud Provider (Supabase / Local during development)

---

## 9. API Documentation & Testing

### API Endpoints List

- POST /api/groups  
  Create a new expense group

- POST /api/groups/:id/expenses  
  Add expense to a group

- GET /api/groups/:id/balances  
  Calculate net balances

- GET /api/groups/:id/optimize  
  Apply minimum cash flow optimization

### API Testing Screenshots
(To be added after backend implementation using Thunder Client / Postman)

---

## 10. Module-wise Development & Deliverables

### Checkpoint 1: Research & Planning
- Finalized problem understanding and scope
- Defined MVP feature set
- Selected technology stack
- Designed database schema structure
- Defined optimization algorithm approach
- Structured repository with clean commit history

### Checkpoint 2: Backend Development
- Implement database schema in Prisma
- Implement expense creation APIs
- Implement net balance calculation logic
- Implement optimization engine

### Checkpoint 3: Frontend Development
- Build dashboard UI
- Group detail page
- Expense logging interface
- Settlement comparison view

### Checkpoint 4: Model Training
- Not applicable (Algorithm-based optimization model)

### Checkpoint 5: Model Integration
- Integrate optimization engine with API layer
- Display simplified settlements

### Checkpoint 6: Deployment
- Deploy application to Vercel
- Connect PostgreSQL database
- Perform end-to-end testing

---

## 11. End-to-End Workflow

1. User creates a group.
2. Members are added to the group.
3. Expenses are logged with payer and amount.
4. System calculates net balance per user.
5. Optimization engine processes balances.
6. Simplified settlements are generated.
7. User views reduced transaction list.

---

## 12. Demo & Video

- Live Demo Link: (To be added after deployment)
- Demo Video Link: (To be added before final submission)
- GitHub Repository: https://github.com/Rudrxxx/YourSplit

---

## 13. Hackathon Deliverables Summary

- Structured full-stack application
- Graph-based debt optimization algorithm
- Clean and documented database schema
- Deployed working MVP

---

## 14. Team Roles & Responsibilities

| Member Name | Role | Responsibilities |
|-------------|------|-----------------|
| Rudransh Gupta | System Architect & Optimization Lead | System design, database schema, optimization algorithm, backend logic |
| Rounak Kumar Saw | Backend Developer | API implementation, database integration, testing |
| Priyanshu Verma | Frontend Developer | UI design, page structure, API integration |

---

## 15. Future Scope & Scalability

### Short-Term
- Partial payment support
- Recurring expense automation
- Improved debt visualization

### Long-Term
- Multi-currency support
- Payment gateway integration
- AI-based expense prediction
- Microservices-based scaling architecture

---

## 17. Impact

- Reduces number of settlement transactions
- Improves financial transparency within groups
- Demonstrates practical use of graph optimization