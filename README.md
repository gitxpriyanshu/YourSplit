# YourSplit

An optimized peer-to-peer expense splitting platform that minimizes the number of settlement transactions using graph-based algorithms.

---

## 1. Problem Statement

### Problem Title
Peer-to-Peer Expense Splitter with Debt Simplification

### Problem Description
Managing shared expenses in groups often results in complex debt chains and unnecessary transactions. Existing tools calculate balances but do not optimize settlements.

### Target Users
- Flatmates
- Travel groups
- Friends
- Small teams
- Families

### Existing Gaps
- No transaction minimization
- Redundant payment chains
- Poor visualization of debt graph
- Lack of optimization layer

---

## 2. Problem Understanding & Approach

### Root Cause Analysis
Most expense splitters calculate balances but do not apply graph optimization techniques to reduce total settlement transactions.

### Solution Strategy
Model users as nodes in a graph and debts as directed weighted edges.
Apply a Minimum Cash Flow algorithm to reduce the number of transactions while preserving net balances.

---

## 3. Proposed Solution

### Solution Overview
YourSplit calculates group expenses, determines net balances, and applies a graph-based optimization algorithm to minimize required settlements.

### Core Idea
Use a greedy minimum cash flow algorithm to match largest debtor with largest creditor until all balances settle.

### Key Features
- Group expense tracking
- Net balance calculation
- Debt simplification engine
- Before vs After settlement comparison

---

## 4. System Architecture

### High-Level Flow
User → Next.js Frontend → API Routes → Optimization Engine → PostgreSQL Database → Response

### Architecture Description
The system follows a full-stack TypeScript architecture using Next.js App Router. 
Frontend components interact with API routes that handle business logic. 
The optimization engine processes net balances and computes minimum settlement transactions. 
All financial data is stored in PostgreSQL using Prisma ORM.

### Architecture Diagram
(To be added before final submission)

---

## 5. Database Design

### ER Diagram
(To be added before final submission)

### ER Diagram Description

The system consists of the following core entities:

1. User  
   - id (UUID)  
   - name  
   - email  
   - createdAt  

2. Group  
   - id (UUID)  
   - name  
   - createdAt  

3. Expense  
   - id (UUID)  
   - groupId (Foreign Key)  
   - paidById (Foreign Key → User)  
   - amount (Integer, stored in cents)  
   - createdAt  

4. Settlement  
   - id (UUID)  
   - groupId (Foreign Key)  
   - fromUser  
   - toUser  
   - amount (Integer, stored in cents)  
   - optimized (Boolean)  
   - createdAt  

Relationships:
- A Group has many Users (many-to-many).
- A Group has many Expenses.
- An Expense belongs to one Group.
- An Expense is paid by one User.
- Settlements represent optimized transactions between users.

---

## 6. Dataset Selected

### Dataset Name
User-Generated Expense Data

### Source
Manually entered group expense records within the application

### Data Type
Structured financial transaction data (numerical + relational)

### Selection Reason
The optimization model requires structured expense data containing:
- User IDs
- Paid amount
- Group associations
- Debt relationships

Since the system focuses on real-time expense splitting, the dataset is dynamically generated by users.

### Preprocessing Steps
- Convert all monetary values into integer cents to avoid floating point precision errors.
- Compute net balance per user within each group.
- Separate creditors and debtors before applying optimization.

---

## 7. Model Selected

### Model Name
Graph-Based Minimum Cash Flow Optimization Algorithm

### Selection Reasoning
The core problem is minimizing the number of settlement transactions while preserving correct net balances.

Instead of using machine learning, the problem is modeled as a directed weighted graph:
- Nodes represent users.
- Edges represent debt relationships.
- We compute net balances and apply a greedy matching strategy between largest debtor and largest creditor.

This guarantees reduction in transaction count while maintaining financial correctness.

### Alternatives Considered
- Naive settlement (direct pairwise payments)
- Circular debt resolution without optimization
- Linear debt propagation

These approaches do not guarantee minimal transactions.

### Evaluation Metrics
- Reduction in number of settlement transactions
- Correct preservation of net balances
- Time complexity efficiency (O(n log n))

---

## 8. Technology Stack

### Frontend
- Next.js 14 (App Router)
- TypeScript
- Tailwind CSS

### Backend
- Next.js API Routes
- TypeScript
- Prisma ORM

### ML/AI
- Not applicable (Graph-based optimization algorithm implemented manually)

### Database
- PostgreSQL

### Deployment
- Vercel (Frontend + API)
- PostgreSQL Cloud Provider (Supabase / Local during development)